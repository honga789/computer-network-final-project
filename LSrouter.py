####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

import json
from router import Router
from packet import Packet

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.seq_num = 0
        self.links_info = {}  # neighbor_addr -> (port, cost)
        self.lsdb = {}        # router_addr -> (seq_num, {neighbor_addr: cost})
        self.forwarding_table = {}  # dst_addr -> port

        # Initialize this router's own LSDB entry
        self.lsdb[self.addr] = (self.seq_num, {})

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dst_addr in self.forwarding_table:
                next_port = self.forwarding_table[packet.dst_addr]
                self.send(next_port, packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            data = json.loads(packet.content)
            seq = data["seq"]
            neighbors = data["neighbors"]
            src = packet.src_addr

            if src not in self.lsdb or seq > self.lsdb[src][0]:
                self.lsdb[src] = (seq, neighbors)
                self.recompute_forwarding_table()

                for neighbor, (p, _) in self.links_info.items():
                    if neighbor != packet.src_addr:
                        self.send(p, packet)

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.links_info[endpoint] = (port, cost)
        self.seq_num += 1

        neighbors = {n: c for n, (p, c) in self.links_info.items()}
        self.lsdb[self.addr] = (self.seq_num, neighbors)

        self.recompute_forwarding_table()
        self.broadcast_lsp()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        neighbor = None
        for n, (p, _) in self.links_info.items():
            if p == port:
                neighbor = n
                break

        if neighbor:
            del self.links_info[neighbor]
            self.seq_num += 1
            neighbors = {n: c for n, (p, c) in self.links_info.items()}
            self.lsdb[self.addr] = (self.seq_num, neighbors)

            self.recompute_forwarding_table()
            self.broadcast_lsp()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            self.broadcast_lsp()

    def broadcast_lsp(self):
        neighbors = {n: c for n, (p, c) in self.links_info.items()}
        content = json.dumps({
            "seq": self.seq_num,
            "neighbors": neighbors
        })
        for neighbor, (port, _) in self.links_info.items():
            packet = Packet(Packet.ROUTING, self.addr, neighbor, content=content)
            self.send(port, packet)

    def recompute_forwarding_table(self):
        import heapq
        graph = {}
        for router, (_, nbrs) in self.lsdb.items():
            graph[router] = nbrs.copy()

        dist = {self.addr: 0}
        prev = {}
        heap = [(0, self.addr)]

        while heap:
            d, u = heapq.heappop(heap)
            if d > dist.get(u, float('inf')):
                continue
            for v, cost in graph.get(u, {}).items():
                alt = dist[u] + cost
                if alt < dist.get(v, float('inf')):
                    dist[v] = alt
                    prev[v] = u
                    heapq.heappush(heap, (alt, v))

        new_table = {}
        for dest in dist:
            if dest == self.addr:
                continue
            hop = dest
            while prev.get(hop) != self.addr:
                hop = prev[hop]
            if hop in self.links_info:
                new_table[dest] = self.links_info[hop][0]  # port

        self.forwarding_table = new_table

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr}, table={self.forwarding_table})"
